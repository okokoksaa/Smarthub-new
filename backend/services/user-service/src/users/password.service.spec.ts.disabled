import { Test, TestingModule } from '@nestjs/testing';
import { PasswordService } from './password.service';
import * as bcrypt from 'bcrypt';

jest.mock('bcrypt');

describe('PasswordService', () => {
  let service: PasswordService;

  const mockBcrypt = bcrypt as jest.Mocked<typeof bcrypt>;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [PasswordService],
    }).compile();

    service = module.get<PasswordService>(PasswordService);

    jest.clearAllMocks();
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  describe('hashPassword', () => {
    it('should hash password with generated salt', async () => {
      const password = 'TestPassword123!';
      const salt = 'generated_salt';
      const hash = 'hashed_password';

      mockBcrypt.genSalt.mockResolvedValue(salt as never);
      mockBcrypt.hash.mockResolvedValue(hash as never);

      const result = await service.hashPassword(password);

      expect(result).toEqual({ hash, salt });
      expect(bcrypt.genSalt).toHaveBeenCalledWith(10);
      expect(bcrypt.hash).toHaveBeenCalledWith(password, salt);
    });

    it('should use default salt rounds of 10', async () => {
      const password = 'TestPassword123!';
      mockBcrypt.genSalt.mockResolvedValue('salt' as never);
      mockBcrypt.hash.mockResolvedValue('hash' as never);

      await service.hashPassword(password);

      expect(bcrypt.genSalt).toHaveBeenCalledWith(10);
    });

    it('should handle bcrypt errors', async () => {
      const password = 'TestPassword123!';
      mockBcrypt.genSalt.mockRejectedValue(new Error('Bcrypt error'));

      await expect(service.hashPassword(password)).rejects.toThrow('Bcrypt error');
    });
  });

  describe('verifyPassword', () => {
    it('should return true for correct password', async () => {
      const password = 'TestPassword123!';
      const hash = 'hashed_password';

      mockBcrypt.compare.mockResolvedValue(true as never);

      const result = await service.verifyPassword(password, hash);

      expect(result).toBe(true);
      expect(bcrypt.compare).toHaveBeenCalledWith(password, hash);
    });

    it('should return false for incorrect password', async () => {
      const password = 'WrongPassword';
      const hash = 'hashed_password';

      mockBcrypt.compare.mockResolvedValue(false as never);

      const result = await service.verifyPassword(password, hash);

      expect(result).toBe(false);
      expect(bcrypt.compare).toHaveBeenCalledWith(password, hash);
    });

    it('should handle bcrypt comparison errors', async () => {
      const password = 'TestPassword123!';
      const hash = 'hashed_password';

      mockBcrypt.compare.mockRejectedValue(new Error('Comparison error'));

      await expect(service.verifyPassword(password, hash)).rejects.toThrow('Comparison error');
    });
  });

  describe('validatePasswordStrength', () => {
    it('should accept strong password with all requirements', () => {
      const strongPasswords = [
        'TestPass123!',
        'MyP@ssw0rd',
        'Secure#2024',
        'Complex!Pass1',
      ];

      strongPasswords.forEach(password => {
        expect(() => service.validatePasswordStrength(password)).not.toThrow();
      });
    });

    it('should reject password shorter than 8 characters', () => {
      const shortPasswords = ['Test1!', 'Ab1!', 'Short1!'];

      shortPasswords.forEach(password => {
        expect(() => service.validatePasswordStrength(password)).toThrow(
          'Password must be at least 8 characters long',
        );
      });
    });

    it('should reject password without uppercase letter', () => {
      const noUppercase = ['testpass123!', 'mypassword1!', 'alllowercase1!'];

      noUppercase.forEach(password => {
        expect(() => service.validatePasswordStrength(password)).toThrow(
          'Password must contain at least one uppercase letter',
        );
      });
    });

    it('should reject password without lowercase letter', () => {
      const noLowercase = ['TESTPASS123!', 'MYPASSWORD1!', 'ALLUPPERCASE1!'];

      noLowercase.forEach(password => {
        expect(() => service.validatePasswordStrength(password)).toThrow(
          'Password must contain at least one lowercase letter',
        );
      });
    });

    it('should reject password without number', () => {
      const noNumber = ['TestPassword!', 'MyPassword!', 'NoNumbers!'];

      noNumber.forEach(password => {
        expect(() => service.validatePasswordStrength(password)).toThrow(
          'Password must contain at least one number',
        );
      });
    });

    it('should reject password without special character', () => {
      const noSpecial = ['TestPassword123', 'MyPassword123', 'NoSpecial123'];

      noSpecial.forEach(password => {
        expect(() => service.validatePasswordStrength(password)).toThrow(
          'Password must contain at least one special character',
        );
      });
    });

    it('should accept various special characters', () => {
      const specialChars = [
        'TestPass1@',
        'TestPass1#',
        'TestPass1$',
        'TestPass1%',
        'TestPass1^',
        'TestPass1&',
        'TestPass1*',
        'TestPass1!',
      ];

      specialChars.forEach(password => {
        expect(() => service.validatePasswordStrength(password)).not.toThrow();
      });
    });

    it('should validate minimum length of 8', () => {
      expect(() => service.validatePasswordStrength('Test12!')).toThrow();
      expect(() => service.validatePasswordStrength('Test123!')).not.toThrow();
    });

    it('should handle edge case passwords', () => {
      // Exactly 8 characters with all requirements
      expect(() => service.validatePasswordStrength('Aa1!bcde')).not.toThrow();

      // Very long password
      expect(() =>
        service.validatePasswordStrength('VeryLongPassword123!WithManyCharacters'),
      ).not.toThrow();

      // Multiple special characters
      expect(() => service.validatePasswordStrength('Test@#$123')).not.toThrow();

      // Multiple numbers
      expect(() => service.validatePasswordStrength('TestPass123456!')).not.toThrow();
    });

    it('should reject empty or whitespace passwords', () => {
      expect(() => service.validatePasswordStrength('')).toThrow();
      expect(() => service.validatePasswordStrength('   ')).toThrow();
    });

    it('should handle passwords with spaces', () => {
      // Spaces are technically valid but should still meet other requirements
      expect(() => service.validatePasswordStrength('Test Pass123!')).not.toThrow();
    });
  });

  describe('generateResetToken', () => {
    it('should generate random reset token', () => {
      const token1 = service.generateResetToken();
      const token2 = service.generateResetToken();

      expect(token1).toBeDefined();
      expect(token1.length).toBeGreaterThan(0);
      expect(token2).toBeDefined();
      expect(token2.length).toBeGreaterThan(0);
      expect(token1).not.toBe(token2); // Tokens should be unique
    });

    it('should generate URL-safe tokens', () => {
      const token = service.generateResetToken();

      // Should not contain characters that need URL encoding
      expect(token).toMatch(/^[A-Za-z0-9\-_]+$/);
    });

    it('should generate tokens of consistent length', () => {
      const tokens = Array.from({ length: 10 }, () => service.generateResetToken());

      const lengths = tokens.map(t => t.length);
      const uniqueLengths = new Set(lengths);

      // All tokens should have the same length (32 bytes = 64 hex chars typically)
      expect(uniqueLengths.size).toBe(1);
    });
  });

  describe('isResetTokenExpired', () => {
    it('should return false for recent token (within 1 hour)', () => {
      const recentDate = new Date(Date.now() - 30 * 60 * 1000); // 30 minutes ago

      const result = service.isResetTokenExpired(recentDate);

      expect(result).toBe(false);
    });

    it('should return true for expired token (over 1 hour)', () => {
      const expiredDate = new Date(Date.now() - 2 * 60 * 60 * 1000); // 2 hours ago

      const result = service.isResetTokenExpired(expiredDate);

      expect(result).toBe(true);
    });

    it('should return true for token exactly at 1 hour boundary', () => {
      const boundaryDate = new Date(Date.now() - 60 * 60 * 1000); // Exactly 1 hour ago

      const result = service.isResetTokenExpired(boundaryDate);

      // Should be expired (>= 1 hour)
      expect(result).toBe(true);
    });

    it('should return false for token just before 1 hour', () => {
      const almostExpired = new Date(Date.now() - 59 * 60 * 1000); // 59 minutes ago

      const result = service.isResetTokenExpired(almostExpired);

      expect(result).toBe(false);
    });

    it('should handle future dates (should not be expired)', () => {
      const futureDate = new Date(Date.now() + 30 * 60 * 1000); // 30 minutes in future

      const result = service.isResetTokenExpired(futureDate);

      expect(result).toBe(false);
    });
  });

  describe('password security edge cases', () => {
    it('should handle unicode characters in passwords', () => {
      const unicodePassword = 'Test123!cafÃ©';

      expect(() => service.validatePasswordStrength(unicodePassword)).not.toThrow();
    });

    it('should handle emojis in passwords', () => {
      const emojiPassword = 'Test123!ðŸ˜€';

      // Should validate (meets requirements)
      expect(() => service.validatePasswordStrength(emojiPassword)).not.toThrow();
    });

    it('should consistently hash the same password', async () => {
      const password = 'TestPassword123!';

      mockBcrypt.genSalt.mockResolvedValue('same_salt' as never);
      mockBcrypt.hash.mockResolvedValue('same_hash' as never);

      const result1 = await service.hashPassword(password);
      const result2 = await service.hashPassword(password);

      // With same salt, should produce same hash
      expect(result1.salt).toBe(result2.salt);
      expect(result1.hash).toBe(result2.hash);
    });
  });
});
